//! Left aligned text.
use crate::{
    alignment::HorizontalTextAlignment, parser::Token, rendering::space_config::UniformSpaceConfig,
};
use embedded_graphics::text::TextRenderer;

/// Marks text to be rendered left aligned.
#[derive(Copy, Clone, Debug)]
pub struct LeftAligned;
impl HorizontalTextAlignment for LeftAligned {
    type SpaceConfig = UniformSpaceConfig;

    const STARTING_SPACES: bool = true;
    const ENDING_SPACES: bool = true;

    #[inline]
    fn place_line(
        renderer: &impl TextRenderer,
        _max_width: u32,
        _text_width: u32,
        _n_spaces: u32,
        _carried_token: Option<Token>,
    ) -> (u32, Self::SpaceConfig) {
        (0, UniformSpaceConfig::new(renderer))
    }
}

#[cfg(test)]
mod test {
    use embedded_graphics::{
        geometry::Point,
        mock_display::MockDisplay,
        mono_font::{ascii::Font6x9, MonoTextStyleBuilder},
        pixelcolor::BinaryColor,
        prelude::Size,
        primitives::Rectangle,
        Drawable,
    };

    use crate::{
        alignment::LeftAligned, style::TextBoxStyleBuilder, utils::test::size_for, TextBox,
    };

    fn assert_rendered(text: &str, size: Size, pattern: &[&str]) {
        let mut display = MockDisplay::new();

        let character_style = MonoTextStyleBuilder::new()
            .font(Font6x9)
            .text_color(BinaryColor::On)
            .background_color(BinaryColor::Off)
            .build();

        let style = TextBoxStyleBuilder::new()
            .character_style(character_style)
            .alignment(LeftAligned)
            .build();

        TextBox::new(text, Rectangle::new(Point::zero(), size))
            .into_styled(style)
            .draw(&mut display)
            .unwrap();

        display.assert_pattern(pattern);
    }

    #[test]
    fn simple_render() {
        assert_rendered(
            "word",
            size_for(Font6x9, 6, 1),
            &[
                "........................",
                "......................#.",
                "......................#.",
                "#...#...##...#.#....###.",
                "#.#.#..#..#..##.#..#..#.",
                "#.#.#..#..#..#.....#..#.",
                ".#.#....##...#......###.",
                "........................",
                "........................",
            ],
        );
    }

    #[test]
    fn simple_render_cr() {
        let mut display = MockDisplay::new();
        display.set_allow_overdraw(true);

        let character_style = MonoTextStyleBuilder::new()
            .font(Font6x9)
            .text_color(BinaryColor::On)
            .build();

        let style = TextBoxStyleBuilder::new()
            .character_style(character_style)
            .alignment(LeftAligned)
            .build();

        TextBox::new(
            "O\rX",
            Rectangle::new(Point::zero(), size_for(Font6x9, 1, 1)),
        )
        .into_styled(style)
        .draw(&mut display)
        .unwrap();

        display.assert_pattern(&[
            "         ",
            "#####    ",
            "## ##    ",
            "# # #    ",
            "# # #    ",
            "## ##    ",
            "#####    ",
        ]);
    }

    #[test]
    fn simple_word_wrapping() {
        assert_rendered(
            "word wrapping",
            size_for(Font6x9, 9, 2),
            &[
                "........................                        ",
                "......................#.                        ",
                "......................#.                        ",
                "#...#...##...#.#....###.                        ",
                "#.#.#..#..#..##.#..#..#.                        ",
                "#.#.#..#..#..#.....#..#.                        ",
                ".#.#....##...#......###.                        ",
                "........................                        ",
                "........................                        ",
                "................................................",
                "................................#...............",
                "................................................",
                "#...#..#.#....###..###...###...##....###....##..",
                "#.#.#..##.#..#..#..#..#..#..#...#....#..#..#..#.",
                "#.#.#..#.....#..#..#..#..#..#...#....#..#..#..#.",
                ".#.#...#......###..###...###...###...#..#...###.",
                "...................#.....#....................#.",
                "...................#.....#..................##..",
            ],
        );
    }

    #[test]
    fn simple_word_wrapping_by_space() {
        assert_rendered(
            "wrapping word",
            size_for(Font6x9, 8, 2),
            &[
                "................................................",
                "................................#...............",
                "................................................",
                "#...#..#.#....###..###...###...##....###....##..",
                "#.#.#..##.#..#..#..#..#..#..#...#....#..#..#..#.",
                "#.#.#..#.....#..#..#..#..#..#...#....#..#..#..#.",
                ".#.#...#......###..###...###...###...#..#...###.",
                "...................#.....#....................#.",
                "...................#.....#..................##..",
                "........................                        ",
                "......................#.                        ",
                "......................#.                        ",
                "#...#...##...#.#....###.                        ",
                "#.#.#..#..#..##.#..#..#.                        ",
                "#.#.#..#..#..#.....#..#.                        ",
                ".#.#....##...#......###.                        ",
                "........................                        ",
                "........................                        ",
            ],
        );
    }

    #[test]
    fn simple_word_wrapping_with_line_spacing() {
        let mut display = MockDisplay::new();

        let character_style = MonoTextStyleBuilder::new()
            .font(Font6x9)
            .text_color(BinaryColor::On)
            .background_color(BinaryColor::Off)
            .build();

        let style = TextBoxStyleBuilder::new()
            .character_style(character_style)
            .alignment(LeftAligned)
            .line_spacing(2)
            .build();

        TextBox::new(
            "wrapping word",
            Rectangle::new(Point::zero(), size_for(Font6x9, 8, 3)),
        )
        .into_styled(style)
        .draw(&mut display)
        .unwrap();

        display.assert_pattern(&[
            "................................................",
            "................................#...............",
            "................................................",
            "#...#..#.#....###..###...###...##....###....##..",
            "#.#.#..##.#..#..#..#..#..#..#...#....#..#..#..#.",
            "#.#.#..#.....#..#..#..#..#..#...#....#..#..#..#.",
            ".#.#...#......###..###...###...###...#..#...###.",
            "...................#.....#....................#.",
            "...................#.....#..................##..",
            "                                                ",
            "                                                ",
            "........................                        ",
            "......................#.                        ",
            "......................#.                        ",
            "#...#...##...#.#....###.                        ",
            "#.#.#..#..#..##.#..#..#.                        ",
            "#.#.#..#..#..#.....#..#.                        ",
            ".#.#....##...#......###.                        ",
            "........................                        ",
            "........................                        ",
        ]);
    }

    #[test]
    fn simple_word_wrapping_with_negative_line_spacing() {
        let mut display = MockDisplay::new();
        display.set_allow_overdraw(true);

        let character_style = MonoTextStyleBuilder::new()
            .font(Font6x9)
            .text_color(BinaryColor::On)
            .background_color(BinaryColor::Off)
            .build();

        let style = TextBoxStyleBuilder::new()
            .character_style(character_style)
            .alignment(LeftAligned)
            .line_spacing(-2)
            .build();

        TextBox::new(
            "wrapping word",
            Rectangle::new(Point::zero(), size_for(Font6x9, 8, 2)),
        )
        .into_styled(style)
        .draw(&mut display)
        .unwrap();

        display.assert_pattern(&[
            "................................................",
            "................................#...............",
            "................................................",
            "#...#..#.#....###..###...###...##....###....##..",
            "#.#.#..##.#..#..#..#..#..#..#...#....#..#..#..#.",
            "#.#.#..#.....#..#..#..#..#..#...#....#..#..#..#.",
            ".#.#...#......###..###...###...###...#..#...###.",
            ".........................#....................#.", // note the overdraw
            "......................#..#..................##..",
            "......................#.                        ",
            "#...#...##...#.#....###.                        ",
            "#.#.#..#..#..##.#..#..#.                        ",
            "#.#.#..#..#..#.....#..#.                        ",
            ".#.#....##...#......###.                        ",
            "........................                        ",
            "........................                        ",
        ]);
    }

    #[test]
    fn whitespace_word_wrapping() {
        assert_rendered(
            "word  wrap",
            size_for(Font6x9, 6, 2),
            &[
                "..............................",
                "......................#.......",
                "......................#.......",
                "#...#...##...#.#....###.......",
                "#.#.#..#..#..##.#..#..#.......",
                "#.#.#..#..#..#.....#..#.......",
                ".#.#....##...#......###.......",
                "..............................",
                "..............................",
                "........................      ",
                "........................      ",
                "........................      ",
                "#...#..#.#....###..###..      ",
                "#.#.#..##.#..#..#..#..#.      ",
                "#.#.#..#.....#..#..#..#.      ",
                ".#.#...#......###..###..      ",
                "...................#....      ",
                "...................#....      ",
            ],
        );
    }

    #[test]
    fn word_longer_than_line_wraps_word_and_removes_a_space() {
        assert_rendered(
            "word  somereallylongword",
            size_for(Font6x9, 9, 3),
            &[
                "..............................                        ",
                "......................#.......                        ",
                "......................#.......                        ",
                "#...#...##...#.#....###.......                        ",
                "#.#.#..#..#..##.#..#..#.......                        ",
                "#.#.#..#..#..#.....#..#.......                        ",
                ".#.#....##...#......###.......                        ",
                "..............................                        ",
                "..............................                        ",
                "......................................................",
                "...........................................##....##...",
                "............................................#.....#...",
                "..###...##..##.#....##...#.#....##....###...#.....#...",
                ".##....#..#.#.#.#..#.##..##.#..#.##..#..#...#.....#...",
                "...##..#..#.#.#.#..##....#.....##....#..#...#.....#...",
                ".###....##..#...#...###..#......###...###..###...###..",
                "......................................................",
                "......................................................",
                "......................................................",
                ".......##...........................................#.",
                "........#...........................................#.",
                ".#..#...#.....##...###....##..#...#...##...#.#....###.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..##.#..#..#.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..#.....#..#.",
                "..###..###....##...#..#...###..#.#....##...#......###.",
                ".#..#.......................#.........................",
                "..##......................##..........................",
            ],
        );
    }

    #[test]
    fn first_word_longer_than_line_wraps_word() {
        assert_rendered(
            "somereallylongword",
            size_for(Font6x9, 9, 2),
            &[
                "......................................................",
                "...........................................##....##...",
                "............................................#.....#...",
                "..###...##..##.#....##...#.#....##....###...#.....#...",
                ".##....#..#.#.#.#..#.##..##.#..#.##..#..#...#.....#...",
                "...##..#..#.#.#.#..##....#.....##....#..#...#.....#...",
                ".###....##..#...#...###..#......###...###..###...###..",
                "......................................................",
                "......................................................",
                "......................................................",
                ".......##...........................................#.",
                "........#...........................................#.",
                ".#..#...#.....##...###....##..#...#...##...#.#....###.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..##.#..#..#.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..#.....#..#.",
                "..###..###....##...#..#...###..#.#....##...#......###.",
                ".#..#.......................#.........................",
                "..##......................##..........................",
            ],
        );
    }

    #[test]
    fn soft_hyphen_rendering() {
        assert_rendered(
            "soft\u{AD}hyphen",
            size_for(Font6x9, 6, 2),
            &[
                "..............................      ",
                "...............#....#.........      ",
                "..............#.#...#.........      ",
                "..###...##....#....###........      ",
                ".##....#..#..###....#...#####.      ",
                "...##..#..#...#.....#.#.......      ",
                ".###....##....#......#........      ",
                "..............................      ",
                "..............................      ",
                "....................................",
                ".#.................#................",
                ".#.................#................",
                ".###...#..#..###...###....##...###..",
                ".#..#..#..#..#..#..#..#..#.##..#..#.",
                ".#..#..#..#..#..#..#..#..##....#..#.",
                ".#..#...###..###...#..#...###..#..#.",
                ".......#..#..#......................",
                "........##...#......................",
            ],
        );
    }
}

//! Fully justified text.
use crate::{
    alignment::HorizontalTextAlignment, rendering::space_config::SpaceConfig, utils::str_width,
};
use embedded_graphics::text::TextRenderer;

/// Marks text to be rendered fully justified.
#[derive(Copy, Clone, Debug)]
pub struct Justified;
impl HorizontalTextAlignment for Justified {
    type SpaceConfig = JustifiedSpaceConfig;

    const STARTING_SPACES: bool = false;
    const ENDING_SPACES: bool = false;

    #[inline]
    fn place_line(
        renderer: &impl TextRenderer,
        max_width: u32,
        text_width: u32,
        n_spaces: u32,
        end_of_paragraph: bool,
    ) -> (u32, Self::SpaceConfig) {
        let space_width = str_width(renderer, " ");

        let space_info = if !end_of_paragraph && n_spaces != 0 {
            let space = max_width - (text_width - n_spaces * space_width);
            let space_width = space / n_spaces;
            let extra_pixels = space % n_spaces;
            JustifiedSpaceConfig::new(space_width, extra_pixels)
        } else {
            JustifiedSpaceConfig::new(space_width, 0)
        };
        (0, space_info)
    }
}

/// Internal state information used to store width of whitespace characters when rendering fully
/// justified text.
///
/// The fully justified renderer works by calculating the width of whitespace characters for the
/// current line. Due to integer arithmetic, there can be remainder pixels when a single space
/// width is used. This struct stores two width values so the whole line will always (at least if
/// there's a space in the line) take up all available space.
#[derive(Copy, Clone, Debug)]
pub struct JustifiedSpaceConfig {
    /// The width of the whitespace characters.
    space_width: u32,

    /// Stores how many characters are rendered using the space_width width. This field changes
    /// during rendering.
    space_count: u32,
}

impl JustifiedSpaceConfig {
    #[inline]
    #[must_use]
    fn new(space_width: u32, extra_pixel_count: u32) -> Self {
        JustifiedSpaceConfig {
            space_width,
            space_count: extra_pixel_count,
        }
    }
}

impl SpaceConfig for JustifiedSpaceConfig {
    #[inline]
    fn peek_next_width(&self, whitespace_count: u32) -> u32 {
        whitespace_count * self.space_width + self.space_count.min(whitespace_count)
    }

    #[inline]
    fn consume(&mut self, n: u32) -> u32 {
        let w = self.peek_next_width(n);
        self.space_count = self.space_count.saturating_sub(n);
        w
    }
}

#[cfg(test)]
mod test {
    use embedded_graphics::{
        geometry::Point,
        mock_display::MockDisplay,
        mono_font::{ascii::Font6x9, MonoTextStyleBuilder},
        pixelcolor::BinaryColor,
        prelude::Size,
        primitives::Rectangle,
        Drawable,
    };

    use crate::{alignment::Justified, style::TextBoxStyleBuilder, utils::test::size_for, TextBox};

    fn assert_rendered(text: &str, size: Size, pattern: &[&str]) {
        let mut display = MockDisplay::new();

        let character_style = MonoTextStyleBuilder::new()
            .font(Font6x9)
            .text_color(BinaryColor::On)
            .background_color(BinaryColor::Off)
            .build();

        let style = TextBoxStyleBuilder::new()
            .character_style(character_style)
            .alignment(Justified)
            .build();

        TextBox::new(text, Rectangle::new(Point::zero(), size))
            .into_styled(style)
            .draw(&mut display)
            .unwrap();

        display.assert_pattern(pattern);
    }

    #[test]
    fn simple_render() {
        assert_rendered(
            "word",
            size_for(Font6x9, 6, 1),
            &[
                "........................",
                "......................#.",
                "......................#.",
                "#...#...##...#.#....###.",
                "#.#.#..#..#..##.#..#..#.",
                "#.#.#..#..#..#.....#..#.",
                ".#.#....##...#......###.",
                "........................",
                "........................",
            ],
        );
    }

    #[test]
    fn simple_render_cr() {
        let mut display = MockDisplay::new();
        display.set_allow_overdraw(true);

        let character_style = MonoTextStyleBuilder::new()
            .font(Font6x9)
            .text_color(BinaryColor::On)
            .build();

        let style = TextBoxStyleBuilder::new()
            .character_style(character_style)
            .alignment(Justified)
            .build();

        TextBox::new(
            "O\rX",
            Rectangle::new(Point::zero(), size_for(Font6x9, 1, 1)),
        )
        .into_styled(style)
        .draw(&mut display)
        .unwrap();

        display.assert_pattern(&[
            "         ",
            "#####    ",
            "## ##    ",
            "# # #    ",
            "# # #    ",
            "## ##    ",
            "#####    ",
        ]);
    }

    #[test]
    fn wrapping_when_space_is_less_than_space_character() {
        assert_rendered(
            "A word",
            size_for(Font6x9, 5, 1),
            &[
                "......            ",
                "..#...            ",
                ".#.#..            ",
                "#...#.            ",
                "#####.            ",
                "#...#.            ",
                "#...#.            ",
                "......            ",
                "......            ",
            ],
        );
    }

    #[test]
    fn simple_word_wrapping() {
        assert_rendered(
            "word wrapping",
            size_for(Font6x9, 9, 2),
            &[
                "........................                        ",
                "......................#.                        ",
                "......................#.                        ",
                "#...#...##...#.#....###.                        ",
                "#.#.#..#..#..##.#..#..#.                        ",
                "#.#.#..#..#..#.....#..#.                        ",
                ".#.#....##...#......###.                        ",
                "........................                        ",
                "........................                        ",
                "................................................",
                "................................#...............",
                "................................................",
                "#...#..#.#....###..###...###...##....###....##..",
                "#.#.#..##.#..#..#..#..#..#..#...#....#..#..#..#.",
                "#.#.#..#.....#..#..#..#..#..#...#....#..#..#..#.",
                ".#.#...#......###..###...###...###...#..#...###.",
                "...................#.....#....................#.",
                "...................#.....#..................##..",
            ],
        );
    }

    #[test]
    fn justified_alignment() {
        assert_rendered(
            "word and other word last line",
            size_for(Font6x9, 10, 3),
            &[
                "............................................................",
                "......................#...................................#.",
                "......................#...................................#.",
                "#...#...##...#.#....###.....................###..###....###.",
                "#.#.#..#..#..##.#..#..#....................#..#..#..#..#..#.",
                "#.#.#..#..#..#.....#..#....................#..#..#..#..#..#.",
                ".#.#....##...#......###.....................###..#..#...###.",
                "............................................................",
                "............................................................",
                "............................................................",
                "........#....#............................................#.",
                "........#....#............................................#.",
                "..##...###...###....##...#.#........#...#...##...#.#....###.",
                ".#..#...#....#..#..#.##..##.#.......#.#.#..#..#..##.#..#..#.",
                ".#..#...#.#..#..#..##....#..........#.#.#..#..#..#.....#..#.",
                "..##.....#...#..#...###..#...........#.#....##...#......###.",
                "............................................................",
                "............................................................",
                "......................................................      ",
                ".##.................#..........##.....#...............      ",
                "..#.................#...........#.....................      ",
                "..#.....###...###..###..........#....##....###....##..      ",
                "..#....#..#..##.....#...........#.....#....#..#..#.##.      ",
                "..#....#..#....##...#.#.........#.....#....#..#..##...      ",
                ".###....###..###.....#.........###...###...#..#...###.      ",
                "......................................................      ",
                "......................................................      ",
            ],
        );
    }

    #[test]
    fn word_longer_than_line_wraps_word() {
        assert_rendered(
            "word somereallylongword",
            size_for(Font6x9, 9, 3),
            &[
                "........................                              ",
                "......................#.                              ",
                "......................#.                              ",
                "#...#...##...#.#....###.                              ",
                "#.#.#..#..#..##.#..#..#.                              ",
                "#.#.#..#..#..#.....#..#.                              ",
                ".#.#....##...#......###.                              ",
                "........................                              ",
                "........................                              ",
                "......................................................",
                "...........................................##....##...",
                "............................................#.....#...",
                "..###...##..##.#....##...#.#....##....###...#.....#...",
                ".##....#..#.#.#.#..#.##..##.#..#.##..#..#...#.....#...",
                "...##..#..#.#.#.#..##....#.....##....#..#...#.....#...",
                ".###....##..#...#...###..#......###...###..###...###..",
                "......................................................",
                "......................................................",
                "......................................................",
                ".......##...........................................#.",
                "........#...........................................#.",
                ".#..#...#.....##...###....##..#...#...##...#.#....###.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..##.#..#..#.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..#.....#..#.",
                "..###..###....##...#..#...###..#.#....##...#......###.",
                ".#..#.......................#.........................",
                "..##......................##..........................",
            ],
        );
    }

    #[test]
    fn first_word_longer_than_line_wraps_word() {
        assert_rendered(
            "somereallylongword",
            size_for(Font6x9, 9, 2),
            &[
                "......................................................",
                "...........................................##....##...",
                "............................................#.....#...",
                "..###...##..##.#....##...#.#....##....###...#.....#...",
                ".##....#..#.#.#.#..#.##..##.#..#.##..#..#...#.....#...",
                "...##..#..#.#.#.#..##....#.....##....#..#...#.....#...",
                ".###....##..#...#...###..#......###...###..###...###..",
                "......................................................",
                "......................................................",
                "......................................................",
                ".......##...........................................#.",
                "........#...........................................#.",
                ".#..#...#.....##...###....##..#...#...##...#.#....###.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..##.#..#..#.",
                ".#..#...#....#..#..#..#..#..#.#.#.#..#..#..#.....#..#.",
                "..###..###....##...#..#...###..#.#....##...#......###.",
                ".#..#.......................#.........................",
                "..##......................##..........................",
            ],
        );
    }

    #[test]
    fn soft_hyphen_rendering() {
        assert_rendered(
            "soft\u{AD}hyphen",
            size_for(Font6x9, 6, 2),
            &[
                "..............................      ",
                "...............#....#.........      ",
                "..............#.#...#.........      ",
                "..###...##....#....###........      ",
                ".##....#..#..###....#...#####.      ",
                "...##..#..#...#.....#.#.......      ",
                ".###....##....#......#........      ",
                "..............................      ",
                "..............................      ",
                "....................................",
                ".#.................#................",
                ".#.................#................",
                ".###...#..#..###...###....##...###..",
                ".#..#..#..#..#..#..#..#..#.##..#..#.",
                ".#..#..#..#..#..#..#..#..##....#..#.",
                ".#..#...###..###...#..#...###..#..#.",
                ".......#..#..#......................",
                "........##...#......................",
            ],
        );
    }

    #[test]
    fn tab_rendering() {
        // Expect \t to render as 3 space characters, ignored by the justified alignment.
        assert_rendered(
            "a\ttab + two te xt words",
            size_for(Font6x9, 10, 3),
            &[
                "............................................................",
                "..........................#..........#......................",
                "..........................#..........#..................#...",
                "..###....................###....###..###................#...",
                ".#..#.....................#....#..#..#..#.............#####.",
                ".#..#.....................#.#..#..#..#..#...............#...",
                "..###......................#....###..###................#...",
                "............................................................",
                "............................................................",
                "............................................................",
                "..#..........................#..........................#...",
                "..#..........................#..........................#...",
                ".###..#...#...##............###....##............#..#..###..",
                "..#...#.#.#..#..#............#....#.##............##....#...",
                "..#.#.#.#.#..#..#............#.#..##..............##....#.#.",
                "...#...#.#....##..............#....###...........#..#....#..",
                "............................................................",
                "............................................................",
                "..............................                              ",
                "......................#.......                              ",
                "......................#.......                              ",
                "#...#...##...#.#....###...###.                              ",
                "#.#.#..#..#..##.#..#..#..##...                              ",
                "#.#.#..#..#..#.....#..#....##.                              ",
                ".#.#....##...#......###..###..                              ",
                "..............................                              ",
                "..............................                              ",
            ],
        );
    }
}
